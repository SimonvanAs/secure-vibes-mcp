"""Vulnerability scanner for code review analysis.

Scans source code files for vulnerability patterns and reports matches
with file locations, line numbers, and code snippets.
"""

import re
from dataclasses import dataclass
from pathlib import Path

from securevibes_mcp.agents.vulnerability_patterns import PatternRegistry

# Directories to always ignore during scanning
IGNORED_DIRS = frozenset(
    {
        ".git",
        ".hg",
        ".svn",
        "__pycache__",
        ".pytest_cache",
        ".mypy_cache",
        ".ruff_cache",
        "node_modules",
        ".venv",
        "venv",
        ".env",
        "env",
        ".tox",
        "dist",
        "build",
        ".eggs",
        ".securevibes",
    }
)

# Default file extensions to scan
DEFAULT_EXTENSIONS = frozenset(
    {
        ".py",
        ".pyi",
        ".js",
        ".mjs",
        ".jsx",
        ".ts",
        ".tsx",
        ".go",
        ".java",
        ".rb",
        ".php",
    }
)


@dataclass
class PatternMatch:
    """A vulnerability pattern match found in source code.

    Attributes:
        file_path: Path to the file containing the match.
        line_number: Line number where the match was found.
        code_snippet: The matched code line(s).
        pattern_name: Name of the vulnerability pattern that matched.
        category: STRIDE category of the vulnerability.
        cwe_id: Common Weakness Enumeration identifier.
        severity: Severity level (critical, high, medium, low).
    """

    file_path: Path
    line_number: int
    code_snippet: str
    pattern_name: str
    category: str
    cwe_id: str
    severity: str


class VulnerabilityScanner:
    """Scans source code for vulnerability patterns.

    Uses PatternRegistry to find security issues in code files
    based on STRIDE threat categories.
    """

    def __init__(
        self,
        root_path: Path,
        extensions: list[str] | None = None,
    ) -> None:
        """Initialize the scanner.

        Args:
            root_path: Root directory to scan.
            extensions: File extensions to include (default: Python, JS, etc.).
        """
        self.root_path = root_path
        self.extensions = frozenset(extensions) if extensions else DEFAULT_EXTENSIONS
        self.registry = PatternRegistry()

    def _should_ignore(self, path: Path) -> bool:
        """Check if a path should be ignored.

        Args:
            path: The path to check.

        Returns:
            True if the path should be ignored.
        """
        for part in path.parts:
            if part in IGNORED_DIRS:
                return True
            # Check wildcard patterns
            for ignored in IGNORED_DIRS:
                if "*" in ignored:
                    pattern = ignored.replace("*", ".*")
                    if re.match(pattern, part):
                        return True
        return False

    def discover_files(self) -> list[Path]:
        """Discover source files to scan.

        Returns:
            List of file paths matching the extension filter.
        """
        files: list[Path] = []

        for path in self.root_path.rglob("*"):
            if path.is_file() and not self._should_ignore(path):
                if path.suffix in self.extensions:
                    files.append(path)

        return sorted(files)

    def _scan_file(
        self,
        file_path: Path,
        categories: list[str] | None = None,
    ) -> list[PatternMatch]:
        """Scan a single file for vulnerability patterns.

        Args:
            file_path: Path to the file to scan.
            categories: STRIDE categories to check (default: all).

        Returns:
            List of PatternMatch objects for findings.
        """
        matches: list[PatternMatch] = []

        try:
            content = file_path.read_text(encoding="utf-8", errors="ignore")
            lines = content.splitlines()
        except (OSError, UnicodeDecodeError):
            return matches

        # Get patterns for specified categories
        if categories:
            patterns = []
            for cat in categories:
                patterns.extend(self.registry.get_patterns_for_category(cat))
        else:
            patterns = self.registry.get_all_patterns()

        # Check each pattern against file content
        for pattern in patterns:
            try:
                regex = re.compile(pattern.pattern, re.IGNORECASE | re.MULTILINE)
            except re.error:
                continue

            for match in regex.finditer(content):
                # Calculate line number from match position
                line_number = content[: match.start()].count("\n") + 1

                # Extract code snippet (the matched line with context)
                if 0 < line_number <= len(lines):
                    code_snippet = lines[line_number - 1].strip()
                else:
                    code_snippet = match.group(0).strip()

                matches.append(
                    PatternMatch(
                        file_path=file_path,
                        line_number=line_number,
                        code_snippet=code_snippet,
                        pattern_name=pattern.name,
                        category=pattern.category,
                        cwe_id=pattern.cwe_id,
                        severity=pattern.severity,
                    )
                )

        return matches

    def _matches_component_path(
        self,
        file_path: Path,
        component_paths: list[str],
    ) -> bool:
        """Check if a file path matches any component path.

        Args:
            file_path: The file path to check.
            component_paths: List of component path patterns to match.

        Returns:
            True if the file path matches any component path.
        """
        if not component_paths:
            return True

        path_str = str(file_path)
        for component in component_paths:
            if component in path_str:
                return True
        return False

    def scan_for_patterns(
        self,
        categories: list[str] | None = None,
        component_paths: list[str] | None = None,
    ) -> list[PatternMatch]:
        """Scan all files for vulnerability patterns.

        Args:
            categories: STRIDE categories to check (default: all).
            component_paths: Filter to files matching these path patterns.
                If empty or None, all files are scanned.

        Returns:
            List of PatternMatch objects for all findings.
        """
        all_matches: list[PatternMatch] = []
        files = self.discover_files()

        # Filter by component paths if specified
        if component_paths:
            files = [f for f in files if self._matches_component_path(f, component_paths)]

        for file_path in files:
            matches = self._scan_file(file_path, categories)
            all_matches.extend(matches)

        return all_matches
